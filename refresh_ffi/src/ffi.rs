/* automatically generated by rust-bindgen 0.56.0 */

//! Rust FFI to `Refresh.h`

#![allow(warnings)]

pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const REFRESH_ABI_VERSION: u32 = 0;
pub const REFRESH_MAJOR_VERSION: u32 = 0;
pub const REFRESH_MINOR_VERSION: u32 = 1;
pub const REFRESH_PATCH_VERSION: u32 = 0;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
impl Default for __mbstate_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __darwin_pthread_handler_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_attr_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_rwlock_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
impl Default for _opaque_pthread_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_Device {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_Buffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_Texture {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_Sampler {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_RenderTarget {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_Framebuffer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ShaderModule {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_RenderPass {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ComputePipeline {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_GraphicsPipeline {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_CommandBuffer {
    _unused: [u8; 0],
}
pub const Refresh_PresentMode_REFRESH_PRESENTMODE_IMMEDIATE: Refresh_PresentMode = 0;
pub const Refresh_PresentMode_REFRESH_PRESENTMODE_MAILBOX: Refresh_PresentMode = 1;
pub const Refresh_PresentMode_REFRESH_PRESENTMODE_FIFO: Refresh_PresentMode = 2;
pub const Refresh_PresentMode_REFRESH_PRESENTMODE_FIFO_RELAXED: Refresh_PresentMode = 3;
pub type Refresh_PresentMode = ::std::os::raw::c_uint;
pub const Refresh_PrimitiveType_REFRESH_PRIMITIVETYPE_POINTLIST: Refresh_PrimitiveType = 0;
pub const Refresh_PrimitiveType_REFRESH_PRIMITIVETYPE_LINELIST: Refresh_PrimitiveType = 1;
pub const Refresh_PrimitiveType_REFRESH_PRIMITIVETYPE_LINESTRIP: Refresh_PrimitiveType = 2;
pub const Refresh_PrimitiveType_REFRESH_PRIMITIVETYPE_TRIANGLELIST: Refresh_PrimitiveType = 3;
pub const Refresh_PrimitiveType_REFRESH_PRIMITIVETYPE_TRIANGLESTRIP: Refresh_PrimitiveType = 4;
pub type Refresh_PrimitiveType = ::std::os::raw::c_uint;
pub const Refresh_LoadOp_REFRESH_LOADOP_LOAD: Refresh_LoadOp = 0;
pub const Refresh_LoadOp_REFRESH_LOADOP_CLEAR: Refresh_LoadOp = 1;
pub const Refresh_LoadOp_REFRESH_LOADOP_DONT_CARE: Refresh_LoadOp = 2;
pub type Refresh_LoadOp = ::std::os::raw::c_uint;
pub const Refresh_StoreOp_REFRESH_STOREOP_STORE: Refresh_StoreOp = 0;
pub const Refresh_StoreOp_REFRESH_STOREOP_DONT_CARE: Refresh_StoreOp = 1;
pub type Refresh_StoreOp = ::std::os::raw::c_uint;
pub const Refresh_ClearOptionsBits_REFRESH_CLEAROPTIONS_COLOR: Refresh_ClearOptionsBits = 1;
pub const Refresh_ClearOptionsBits_REFRESH_CLEAROPTIONS_DEPTH: Refresh_ClearOptionsBits = 2;
pub const Refresh_ClearOptionsBits_REFRESH_CLEAROPTIONS_STENCIL: Refresh_ClearOptionsBits = 4;
pub type Refresh_ClearOptionsBits = ::std::os::raw::c_uint;
pub type Refresh_ClearOptions = u32;
pub const Refresh_IndexElementSize_REFRESH_INDEXELEMENTSIZE_16BIT: Refresh_IndexElementSize = 0;
pub const Refresh_IndexElementSize_REFRESH_INDEXELEMENTSIZE_32BIT: Refresh_IndexElementSize = 1;
pub type Refresh_IndexElementSize = ::std::os::raw::c_uint;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R8G8B8A8: Refresh_TextureFormat = 0;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R5G6B5: Refresh_TextureFormat = 1;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_A1R5G5B5: Refresh_TextureFormat = 2;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_B4G4R4A4: Refresh_TextureFormat = 3;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_BC1: Refresh_TextureFormat = 4;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_BC2: Refresh_TextureFormat = 5;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_BC3: Refresh_TextureFormat = 6;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R8G8_SNORM: Refresh_TextureFormat = 7;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R8G8B8A8_SNORM: Refresh_TextureFormat = 8;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_A2R10G10B10: Refresh_TextureFormat = 9;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R16G16: Refresh_TextureFormat = 10;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R16G16B16A16: Refresh_TextureFormat = 11;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R8: Refresh_TextureFormat = 12;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R32_SFLOAT: Refresh_TextureFormat = 13;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R32G32_SFLOAT: Refresh_TextureFormat = 14;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R32G32B32A32_SFLOAT: Refresh_TextureFormat =
    15;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R16_SFLOAT: Refresh_TextureFormat = 16;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R16G16_SFLOAT: Refresh_TextureFormat = 17;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_R16G16B16A16_SFLOAT: Refresh_TextureFormat =
    18;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_D16_UNORM: Refresh_TextureFormat = 19;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_D32_SFLOAT: Refresh_TextureFormat = 20;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_D16_UNORM_S8_UINT: Refresh_TextureFormat = 21;
pub const Refresh_TextureFormat_REFRESH_TEXTUREFORMAT_D32_SFLOAT_S8_UINT: Refresh_TextureFormat =
    22;
pub type Refresh_TextureFormat = ::std::os::raw::c_uint;
pub const Refresh_TextureUsageFlagBits_REFRESH_TEXTUREUSAGE_SAMPLER_BIT:
    Refresh_TextureUsageFlagBits = 1;
pub const Refresh_TextureUsageFlagBits_REFRESH_TEXTUREUSAGE_COLOR_TARGET_BIT:
    Refresh_TextureUsageFlagBits = 2;
pub const Refresh_TextureUsageFlagBits_REFRESH_TEXTUREUSAGE_DEPTH_STENCIL_TARGET_BIT:
    Refresh_TextureUsageFlagBits = 4;
pub type Refresh_TextureUsageFlagBits = ::std::os::raw::c_uint;
pub type Refresh_TextureUsageFlags = u32;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_1: Refresh_SampleCount = 0;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_2: Refresh_SampleCount = 1;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_4: Refresh_SampleCount = 2;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_8: Refresh_SampleCount = 3;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_16: Refresh_SampleCount = 4;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_32: Refresh_SampleCount = 5;
pub const Refresh_SampleCount_REFRESH_SAMPLECOUNT_64: Refresh_SampleCount = 6;
pub type Refresh_SampleCount = ::std::os::raw::c_uint;
pub const Refresh_CubeMapFace_REFRESH_CUBEMAPFACE_POSITIVEX: Refresh_CubeMapFace = 0;
pub const Refresh_CubeMapFace_REFRESH_CUBEMAPFACE_NEGATIVEX: Refresh_CubeMapFace = 1;
pub const Refresh_CubeMapFace_REFRESH_CUBEMAPFACE_POSITIVEY: Refresh_CubeMapFace = 2;
pub const Refresh_CubeMapFace_REFRESH_CUBEMAPFACE_NEGATIVEY: Refresh_CubeMapFace = 3;
pub const Refresh_CubeMapFace_REFRESH_CUBEMAPFACE_POSITIVEZ: Refresh_CubeMapFace = 4;
pub const Refresh_CubeMapFace_REFRESH_CUBEMAPFACE_NEGATIVEZ: Refresh_CubeMapFace = 5;
pub type Refresh_CubeMapFace = ::std::os::raw::c_uint;
pub const Refresh_BufferUsageFlagBits_REFRESH_BUFFERUSAGE_VERTEX_BIT: Refresh_BufferUsageFlagBits =
    1;
pub const Refresh_BufferUsageFlagBits_REFRESH_BUFFERUSAGE_INDEX_BIT: Refresh_BufferUsageFlagBits =
    2;
pub const Refresh_BufferUsageFlagBits_REFRESH_BUFFERUSAGE_COMPUTE_BIT: Refresh_BufferUsageFlagBits =
    4;
pub type Refresh_BufferUsageFlagBits = ::std::os::raw::c_uint;
pub type Refresh_BufferUsageFlags = u32;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_SINGLE:
    Refresh_VertexElementFormat = 0;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_VECTOR2:
    Refresh_VertexElementFormat = 1;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_VECTOR3:
    Refresh_VertexElementFormat = 2;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_VECTOR4:
    Refresh_VertexElementFormat = 3;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_COLOR:
    Refresh_VertexElementFormat = 4;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_BYTE4:
    Refresh_VertexElementFormat = 5;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_SHORT2:
    Refresh_VertexElementFormat = 6;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_SHORT4:
    Refresh_VertexElementFormat = 7;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_NORMALIZEDSHORT2:
    Refresh_VertexElementFormat = 8;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_NORMALIZEDSHORT4:
    Refresh_VertexElementFormat = 9;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_HALFVECTOR2:
    Refresh_VertexElementFormat = 10;
pub const Refresh_VertexElementFormat_REFRESH_VERTEXELEMENTFORMAT_HALFVECTOR4:
    Refresh_VertexElementFormat = 11;
pub type Refresh_VertexElementFormat = ::std::os::raw::c_uint;
pub const Refresh_VertexInputRate_REFRESH_VERTEXINPUTRATE_VERTEX: Refresh_VertexInputRate = 0;
pub const Refresh_VertexInputRate_REFRESH_VERTEXINPUTRATE_INSTANCE: Refresh_VertexInputRate = 1;
pub type Refresh_VertexInputRate = ::std::os::raw::c_uint;
pub const Refresh_FillMode_REFRESH_FILLMODE_FILL: Refresh_FillMode = 0;
pub const Refresh_FillMode_REFRESH_FILLMODE_LINE: Refresh_FillMode = 1;
pub const Refresh_FillMode_REFRESH_FILLMODE_POINT: Refresh_FillMode = 2;
pub type Refresh_FillMode = ::std::os::raw::c_uint;
pub const Refresh_CullMode_REFRESH_CULLMODE_NONE: Refresh_CullMode = 0;
pub const Refresh_CullMode_REFRESH_CULLMODE_FRONT: Refresh_CullMode = 1;
pub const Refresh_CullMode_REFRESH_CULLMODE_BACK: Refresh_CullMode = 2;
pub const Refresh_CullMode_REFRESH_CULLMODE_FRONT_AND_BACK: Refresh_CullMode = 3;
pub type Refresh_CullMode = ::std::os::raw::c_uint;
pub const Refresh_FrontFace_REFRESH_FRONTFACE_COUNTER_CLOCKWISE: Refresh_FrontFace = 0;
pub const Refresh_FrontFace_REFRESH_FRONTFACE_CLOCKWISE: Refresh_FrontFace = 1;
pub type Refresh_FrontFace = ::std::os::raw::c_uint;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_NEVER: Refresh_CompareOp = 0;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_LESS: Refresh_CompareOp = 1;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_EQUAL: Refresh_CompareOp = 2;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_LESS_OR_EQUAL: Refresh_CompareOp = 3;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_GREATER: Refresh_CompareOp = 4;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_NOT_EQUAL: Refresh_CompareOp = 5;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_GREATER_OR_EQUAL: Refresh_CompareOp = 6;
pub const Refresh_CompareOp_REFRESH_COMPAREOP_ALWAYS: Refresh_CompareOp = 7;
pub type Refresh_CompareOp = ::std::os::raw::c_uint;
pub const Refresh_StencilOp_REFRESH_STENCILOP_KEEP: Refresh_StencilOp = 0;
pub const Refresh_StencilOp_REFRESH_STENCILOP_ZERO: Refresh_StencilOp = 1;
pub const Refresh_StencilOp_REFRESH_STENCILOP_REPLACE: Refresh_StencilOp = 2;
pub const Refresh_StencilOp_REFRESH_STENCILOP_INCREMENT_AND_CLAMP: Refresh_StencilOp = 3;
pub const Refresh_StencilOp_REFRESH_STENCILOP_DECREMENT_AND_CLAMP: Refresh_StencilOp = 4;
pub const Refresh_StencilOp_REFRESH_STENCILOP_INVERT: Refresh_StencilOp = 5;
pub const Refresh_StencilOp_REFRESH_STENCILOP_INCREMENT_AND_WRAP: Refresh_StencilOp = 6;
pub const Refresh_StencilOp_REFRESH_STENCILOP_DECREMENT_AND_WRAP: Refresh_StencilOp = 7;
pub type Refresh_StencilOp = ::std::os::raw::c_uint;
pub const Refresh_BlendOp_REFRESH_BLENDOP_ADD: Refresh_BlendOp = 0;
pub const Refresh_BlendOp_REFRESH_BLENDOP_SUBTRACT: Refresh_BlendOp = 1;
pub const Refresh_BlendOp_REFRESH_BLENDOP_REVERSE_SUBTRACT: Refresh_BlendOp = 2;
pub const Refresh_BlendOp_REFRESH_BLENDOP_MIN: Refresh_BlendOp = 3;
pub const Refresh_BlendOp_REFRESH_BLENDOP_MAX: Refresh_BlendOp = 4;
pub type Refresh_BlendOp = ::std::os::raw::c_uint;
pub const Refresh_LogicOp_REFRESH_LOGICOP_CLEAR: Refresh_LogicOp = 0;
pub const Refresh_LogicOp_REFRESH_LOGICOP_AND: Refresh_LogicOp = 1;
pub const Refresh_LogicOp_REFRESH_LOGICOP_AND_REVERSE: Refresh_LogicOp = 2;
pub const Refresh_LogicOp_REFRESH_LOGICOP_COPY: Refresh_LogicOp = 3;
pub const Refresh_LogicOp_REFRESH_LOGICOP_AND_INVERTED: Refresh_LogicOp = 4;
pub const Refresh_LogicOp_REFRESH_LOGICOP_NO_OP: Refresh_LogicOp = 5;
pub const Refresh_LogicOp_REFRESH_LOGICOP_XOR: Refresh_LogicOp = 6;
pub const Refresh_LogicOp_REFRESH_LOGICOP_OR: Refresh_LogicOp = 7;
pub const Refresh_LogicOp_REFRESH_LOGICOP_NOR: Refresh_LogicOp = 8;
pub const Refresh_LogicOp_REFRESH_LOGICOP_EQUIVALENT: Refresh_LogicOp = 9;
pub const Refresh_LogicOp_REFRESH_LOGICOP_INVERT: Refresh_LogicOp = 10;
pub const Refresh_LogicOp_REFRESH_LOGICOP_OR_REVERSE: Refresh_LogicOp = 11;
pub const Refresh_LogicOp_REFRESH_LOGICOP_COPY_INVERTED: Refresh_LogicOp = 12;
pub const Refresh_LogicOp_REFRESH_LOGICOP_OR_INVERTED: Refresh_LogicOp = 13;
pub const Refresh_LogicOp_REFRESH_LOGICOP_NAND: Refresh_LogicOp = 14;
pub const Refresh_LogicOp_REFRESH_LOGICOP_SET: Refresh_LogicOp = 15;
pub type Refresh_LogicOp = ::std::os::raw::c_uint;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ZERO: Refresh_BlendFactor = 0;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE: Refresh_BlendFactor = 1;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_SRC_COLOR: Refresh_BlendFactor = 2;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_SRC_COLOR: Refresh_BlendFactor = 3;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_DST_COLOR: Refresh_BlendFactor = 4;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_DST_COLOR: Refresh_BlendFactor = 5;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_SRC_ALPHA: Refresh_BlendFactor = 6;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: Refresh_BlendFactor = 7;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_DST_ALPHA: Refresh_BlendFactor = 8;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_DST_ALPHA: Refresh_BlendFactor = 9;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_CONSTANT_COLOR: Refresh_BlendFactor = 10;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR: Refresh_BlendFactor =
    11;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_CONSTANT_ALPHA: Refresh_BlendFactor = 12;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_CONSTANT_ALPHA: Refresh_BlendFactor =
    13;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_SRC_ALPHA_SATURATE: Refresh_BlendFactor = 14;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_SRC1_COLOR: Refresh_BlendFactor = 15;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_SRC1_COLOR: Refresh_BlendFactor = 16;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_SRC1_ALPHA: Refresh_BlendFactor = 17;
pub const Refresh_BlendFactor_REFRESH_BLENDFACTOR_ONE_MINUS_SRC1_ALPHA: Refresh_BlendFactor = 18;
pub type Refresh_BlendFactor = ::std::os::raw::c_uint;
pub const Refresh_ColorComponentFlagBits_REFRESH_COLORCOMPONENT_R_BIT:
    Refresh_ColorComponentFlagBits = 1;
pub const Refresh_ColorComponentFlagBits_REFRESH_COLORCOMPONENT_G_BIT:
    Refresh_ColorComponentFlagBits = 2;
pub const Refresh_ColorComponentFlagBits_REFRESH_COLORCOMPONENT_B_BIT:
    Refresh_ColorComponentFlagBits = 4;
pub const Refresh_ColorComponentFlagBits_REFRESH_COLORCOMPONENT_A_BIT:
    Refresh_ColorComponentFlagBits = 8;
pub type Refresh_ColorComponentFlagBits = ::std::os::raw::c_uint;
pub type Refresh_ColorComponentFlags = u32;
pub const Refresh_ShaderStageType_REFRESH_SHADERSTAGE_VERTEX: Refresh_ShaderStageType = 0;
pub const Refresh_ShaderStageType_REFRESH_SHADERSTAGE_FRAGMENT: Refresh_ShaderStageType = 1;
pub type Refresh_ShaderStageType = ::std::os::raw::c_uint;
pub const Refresh_Filter_REFRESH_FILTER_NEAREST: Refresh_Filter = 0;
pub const Refresh_Filter_REFRESH_FILTER_LINEAR: Refresh_Filter = 1;
pub const Refresh_Filter_REFRESH_FILTER_CUBIC: Refresh_Filter = 2;
pub type Refresh_Filter = ::std::os::raw::c_uint;
pub const Refresh_SamplerMipmapMode_REFRESH_SAMPLERMIPMAPMODE_NEAREST: Refresh_SamplerMipmapMode =
    0;
pub const Refresh_SamplerMipmapMode_REFRESH_SAMPLERMIPMAPMODE_LINEAR: Refresh_SamplerMipmapMode = 1;
pub type Refresh_SamplerMipmapMode = ::std::os::raw::c_uint;
pub const Refresh_SamplerAddressMode_REFRESH_SAMPLERADDRESSMODE_REPEAT: Refresh_SamplerAddressMode =
    0;
pub const Refresh_SamplerAddressMode_REFRESH_SAMPLERADDRESSMODE_MIRRORED_REPEAT:
    Refresh_SamplerAddressMode = 1;
pub const Refresh_SamplerAddressMode_REFRESH_SAMPLERADDRESSMODE_CLAMP_TO_EDGE:
    Refresh_SamplerAddressMode = 2;
pub const Refresh_SamplerAddressMode_REFRESH_SAMPLERADDRESSMODE_CLAMP_TO_BORDER:
    Refresh_SamplerAddressMode = 3;
pub type Refresh_SamplerAddressMode = ::std::os::raw::c_uint;
pub const Refresh_BorderColor_REFRESH_BORDERCOLOR_FLOAT_TRANSPARENT_BLACK: Refresh_BorderColor = 0;
pub const Refresh_BorderColor_REFRESH_BORDERCOLOR_INT_TRANSPARENT_BLACK: Refresh_BorderColor = 1;
pub const Refresh_BorderColor_REFRESH_BORDERCOLOR_FLOAT_OPAQUE_BLACK: Refresh_BorderColor = 2;
pub const Refresh_BorderColor_REFRESH_BORDERCOLOR_INT_OPAQUE_BLACK: Refresh_BorderColor = 3;
pub const Refresh_BorderColor_REFRESH_BORDERCOLOR_FLOAT_OPAQUE_WHITE: Refresh_BorderColor = 4;
pub const Refresh_BorderColor_REFRESH_BORDERCOLOR_INT_OPAQUE_WHITE: Refresh_BorderColor = 5;
pub type Refresh_BorderColor = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Refresh_DepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
#[test]
fn bindgen_test_layout_Refresh_DepthStencilValue() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_DepthStencilValue>(),
        8usize,
        concat!("Size of: ", stringify!(Refresh_DepthStencilValue))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_DepthStencilValue>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_DepthStencilValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_DepthStencilValue>())).depth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilValue),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilValue>())).stencil as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilValue),
            "::",
            stringify!(stencil)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Refresh_Rect {
    pub x: i32,
    pub y: i32,
    pub w: i32,
    pub h: i32,
}
#[test]
fn bindgen_test_layout_Refresh_Rect() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(Refresh_Rect))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_Rect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Rect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Rect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Rect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Rect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Rect),
            "::",
            stringify!(h)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Refresh_Vec4 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
    pub w: f32,
}
#[test]
fn bindgen_test_layout_Refresh_Vec4() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_Vec4>(),
        16usize,
        concat!("Size of: ", stringify!(Refresh_Vec4))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_Vec4>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_Vec4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Vec4>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Vec4),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Vec4>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Vec4),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Vec4>())).z as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Vec4),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Vec4>())).w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Vec4),
            "::",
            stringify!(w)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Refresh_Viewport {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}
#[test]
fn bindgen_test_layout_Refresh_Viewport() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_Viewport>(),
        24usize,
        concat!("Size of: ", stringify!(Refresh_Viewport))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_Viewport>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_Viewport))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Viewport>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Viewport),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Viewport>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Viewport),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Viewport>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Viewport),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Viewport>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Viewport),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Viewport>())).minDepth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Viewport),
            "::",
            stringify!(minDepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_Viewport>())).maxDepth as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_Viewport),
            "::",
            stringify!(maxDepth)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_TextureSlice {
    pub texture: *mut Refresh_Texture,
    pub rectangle: Refresh_Rect,
    pub depth: u32,
    pub layer: u32,
    pub level: u32,
}
#[test]
fn bindgen_test_layout_Refresh_TextureSlice() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_TextureSlice>(),
        40usize,
        concat!("Size of: ", stringify!(Refresh_TextureSlice))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_TextureSlice>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_TextureSlice))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureSlice>())).texture as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureSlice),
            "::",
            stringify!(texture)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureSlice>())).rectangle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureSlice),
            "::",
            stringify!(rectangle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureSlice>())).depth as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureSlice),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureSlice>())).layer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureSlice),
            "::",
            stringify!(layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureSlice>())).level as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureSlice),
            "::",
            stringify!(level)
        )
    );
}
impl Default for Refresh_TextureSlice {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_PresentationParameters {
    pub deviceWindowHandle: *mut ::std::os::raw::c_void,
    pub presentMode: Refresh_PresentMode,
}
#[test]
fn bindgen_test_layout_Refresh_PresentationParameters() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_PresentationParameters>(),
        16usize,
        concat!("Size of: ", stringify!(Refresh_PresentationParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_PresentationParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_PresentationParameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_PresentationParameters>())).deviceWindowHandle
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_PresentationParameters),
            "::",
            stringify!(deviceWindowHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_PresentationParameters>())).presentMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_PresentationParameters),
            "::",
            stringify!(presentMode)
        )
    );
}
impl Default for Refresh_PresentationParameters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_SamplerStateCreateInfo {
    pub minFilter: Refresh_Filter,
    pub magFilter: Refresh_Filter,
    pub mipmapMode: Refresh_SamplerMipmapMode,
    pub addressModeU: Refresh_SamplerAddressMode,
    pub addressModeV: Refresh_SamplerAddressMode,
    pub addressModeW: Refresh_SamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: u8,
    pub maxAnisotropy: f32,
    pub compareEnable: u8,
    pub compareOp: Refresh_CompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: Refresh_BorderColor,
}
#[test]
fn bindgen_test_layout_Refresh_SamplerStateCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_SamplerStateCreateInfo>(),
        56usize,
        concat!("Size of: ", stringify!(Refresh_SamplerStateCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_SamplerStateCreateInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_SamplerStateCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).minFilter as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(minFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).magFilter as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(magFilter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).mipmapMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(mipmapMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).addressModeU as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(addressModeU)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).addressModeV as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(addressModeV)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).addressModeW as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(addressModeW)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).mipLodBias as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(mipLodBias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).anisotropyEnable as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(anisotropyEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).maxAnisotropy as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(maxAnisotropy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).compareEnable as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(compareEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).compareOp as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(compareOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).minLod as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(minLod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).maxLod as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(maxLod)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SamplerStateCreateInfo>())).borderColor as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SamplerStateCreateInfo),
            "::",
            stringify!(borderColor)
        )
    );
}
impl Default for Refresh_SamplerStateCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_VertexBinding {
    pub binding: u32,
    pub stride: u32,
    pub inputRate: Refresh_VertexInputRate,
}
#[test]
fn bindgen_test_layout_Refresh_VertexBinding() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_VertexBinding>(),
        12usize,
        concat!("Size of: ", stringify!(Refresh_VertexBinding))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_VertexBinding>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_VertexBinding))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_VertexBinding>())).binding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexBinding),
            "::",
            stringify!(binding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_VertexBinding>())).stride as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexBinding),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_VertexBinding>())).inputRate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexBinding),
            "::",
            stringify!(inputRate)
        )
    );
}
impl Default for Refresh_VertexBinding {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_VertexAttribute {
    pub location: u32,
    pub binding: u32,
    pub format: Refresh_VertexElementFormat,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_Refresh_VertexAttribute() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_VertexAttribute>(),
        16usize,
        concat!("Size of: ", stringify!(Refresh_VertexAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_VertexAttribute>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_VertexAttribute))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_VertexAttribute>())).location as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexAttribute),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_VertexAttribute>())).binding as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexAttribute),
            "::",
            stringify!(binding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_VertexAttribute>())).format as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexAttribute),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_VertexAttribute>())).offset as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexAttribute),
            "::",
            stringify!(offset)
        )
    );
}
impl Default for Refresh_VertexAttribute {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_VertexInputState {
    pub vertexBindings: *const Refresh_VertexBinding,
    pub vertexBindingCount: u32,
    pub vertexAttributes: *const Refresh_VertexAttribute,
    pub vertexAttributeCount: u32,
}
#[test]
fn bindgen_test_layout_Refresh_VertexInputState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_VertexInputState>(),
        32usize,
        concat!("Size of: ", stringify!(Refresh_VertexInputState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_VertexInputState>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_VertexInputState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_VertexInputState>())).vertexBindings as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexInputState),
            "::",
            stringify!(vertexBindings)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_VertexInputState>())).vertexBindingCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexInputState),
            "::",
            stringify!(vertexBindingCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_VertexInputState>())).vertexAttributes as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexInputState),
            "::",
            stringify!(vertexAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_VertexInputState>())).vertexAttributeCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_VertexInputState),
            "::",
            stringify!(vertexAttributeCount)
        )
    );
}
impl Default for Refresh_VertexInputState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_StencilOpState {
    pub failOp: Refresh_StencilOp,
    pub passOp: Refresh_StencilOp,
    pub depthFailOp: Refresh_StencilOp,
    pub compareOp: Refresh_CompareOp,
    pub compareMask: u32,
    pub writeMask: u32,
    pub reference: u32,
}
#[test]
fn bindgen_test_layout_Refresh_StencilOpState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_StencilOpState>(),
        28usize,
        concat!("Size of: ", stringify!(Refresh_StencilOpState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_StencilOpState>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_StencilOpState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_StencilOpState>())).failOp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(failOp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_StencilOpState>())).passOp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(passOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_StencilOpState>())).depthFailOp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(depthFailOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_StencilOpState>())).compareOp as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(compareOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_StencilOpState>())).compareMask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(compareMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_StencilOpState>())).writeMask as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(writeMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_StencilOpState>())).reference as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_StencilOpState),
            "::",
            stringify!(reference)
        )
    );
}
impl Default for Refresh_StencilOpState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ColorTargetBlendState {
    pub blendEnable: u8,
    pub srcColorBlendFactor: Refresh_BlendFactor,
    pub dstColorBlendFactor: Refresh_BlendFactor,
    pub colorBlendOp: Refresh_BlendOp,
    pub srcAlphaBlendFactor: Refresh_BlendFactor,
    pub dstAlphaBlendFactor: Refresh_BlendFactor,
    pub alphaBlendOp: Refresh_BlendOp,
    pub colorWriteMask: Refresh_ColorComponentFlags,
}
#[test]
fn bindgen_test_layout_Refresh_ColorTargetBlendState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ColorTargetBlendState>(),
        32usize,
        concat!("Size of: ", stringify!(Refresh_ColorTargetBlendState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ColorTargetBlendState>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_ColorTargetBlendState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).blendEnable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(blendEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).srcColorBlendFactor
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(srcColorBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).dstColorBlendFactor
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(dstColorBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).colorBlendOp as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(colorBlendOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).srcAlphaBlendFactor
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(srcAlphaBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).dstAlphaBlendFactor
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(dstAlphaBlendFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).alphaBlendOp as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(alphaBlendOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetBlendState>())).colorWriteMask as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetBlendState),
            "::",
            stringify!(colorWriteMask)
        )
    );
}
impl Default for Refresh_ColorTargetBlendState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Refresh_ComputePipelineLayoutCreateInfo {
    pub bufferBindingCount: u32,
    pub imageBindingCount: u32,
}
#[test]
fn bindgen_test_layout_Refresh_ComputePipelineLayoutCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ComputePipelineLayoutCreateInfo>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Refresh_ComputePipelineLayoutCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ComputePipelineLayoutCreateInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_ComputePipelineLayoutCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ComputePipelineLayoutCreateInfo>())).bufferBindingCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ComputePipelineLayoutCreateInfo),
            "::",
            stringify!(bufferBindingCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ComputePipelineLayoutCreateInfo>())).imageBindingCount
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ComputePipelineLayoutCreateInfo),
            "::",
            stringify!(imageBindingCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Refresh_GraphicsPipelineLayoutCreateInfo {
    pub vertexSamplerBindingCount: u32,
    pub fragmentSamplerBindingCount: u32,
}
#[test]
fn bindgen_test_layout_Refresh_GraphicsPipelineLayoutCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_GraphicsPipelineLayoutCreateInfo>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Refresh_GraphicsPipelineLayoutCreateInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_GraphicsPipelineLayoutCreateInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_GraphicsPipelineLayoutCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineLayoutCreateInfo>()))
                .vertexSamplerBindingCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineLayoutCreateInfo),
            "::",
            stringify!(vertexSamplerBindingCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineLayoutCreateInfo>()))
                .fragmentSamplerBindingCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineLayoutCreateInfo),
            "::",
            stringify!(fragmentSamplerBindingCount)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ColorTargetDescription {
    pub format: Refresh_TextureFormat,
    pub multisampleCount: Refresh_SampleCount,
    pub loadOp: Refresh_LoadOp,
    pub storeOp: Refresh_StoreOp,
}
#[test]
fn bindgen_test_layout_Refresh_ColorTargetDescription() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ColorTargetDescription>(),
        16usize,
        concat!("Size of: ", stringify!(Refresh_ColorTargetDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ColorTargetDescription>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_ColorTargetDescription))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetDescription>())).format as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetDescription),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetDescription>())).multisampleCount as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetDescription),
            "::",
            stringify!(multisampleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetDescription>())).loadOp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetDescription),
            "::",
            stringify!(loadOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorTargetDescription>())).storeOp as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorTargetDescription),
            "::",
            stringify!(storeOp)
        )
    );
}
impl Default for Refresh_ColorTargetDescription {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_DepthStencilTargetDescription {
    pub depthStencilFormat: Refresh_TextureFormat,
    pub loadOp: Refresh_LoadOp,
    pub storeOp: Refresh_StoreOp,
    pub stencilLoadOp: Refresh_LoadOp,
    pub stencilStoreOp: Refresh_StoreOp,
}
#[test]
fn bindgen_test_layout_Refresh_DepthStencilTargetDescription() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_DepthStencilTargetDescription>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(Refresh_DepthStencilTargetDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_DepthStencilTargetDescription>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_DepthStencilTargetDescription)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilTargetDescription>())).depthStencilFormat
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilTargetDescription),
            "::",
            stringify!(depthStencilFormat)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilTargetDescription>())).loadOp as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilTargetDescription),
            "::",
            stringify!(loadOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilTargetDescription>())).storeOp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilTargetDescription),
            "::",
            stringify!(storeOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilTargetDescription>())).stencilLoadOp
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilTargetDescription),
            "::",
            stringify!(stencilLoadOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilTargetDescription>())).stencilStoreOp
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilTargetDescription),
            "::",
            stringify!(stencilStoreOp)
        )
    );
}
impl Default for Refresh_DepthStencilTargetDescription {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_RenderPassCreateInfo {
    pub colorTargetDescriptions: *const Refresh_ColorTargetDescription,
    pub colorTargetCount: u32,
    pub depthTargetDescription: *const Refresh_DepthStencilTargetDescription,
}
#[test]
fn bindgen_test_layout_Refresh_RenderPassCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_RenderPassCreateInfo>(),
        24usize,
        concat!("Size of: ", stringify!(Refresh_RenderPassCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_RenderPassCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_RenderPassCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RenderPassCreateInfo>())).colorTargetDescriptions
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RenderPassCreateInfo),
            "::",
            stringify!(colorTargetDescriptions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RenderPassCreateInfo>())).colorTargetCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RenderPassCreateInfo),
            "::",
            stringify!(colorTargetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RenderPassCreateInfo>())).depthTargetDescription
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RenderPassCreateInfo),
            "::",
            stringify!(depthTargetDescription)
        )
    );
}
impl Default for Refresh_RenderPassCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ShaderModuleCreateInfo {
    pub codeSize: size_t,
    pub byteCode: *const u32,
}
#[test]
fn bindgen_test_layout_Refresh_ShaderModuleCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ShaderModuleCreateInfo>(),
        16usize,
        concat!("Size of: ", stringify!(Refresh_ShaderModuleCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ShaderModuleCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_ShaderModuleCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ShaderModuleCreateInfo>())).codeSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ShaderModuleCreateInfo),
            "::",
            stringify!(codeSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ShaderModuleCreateInfo>())).byteCode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ShaderModuleCreateInfo),
            "::",
            stringify!(byteCode)
        )
    );
}
impl Default for Refresh_ShaderModuleCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_TextureCreateInfo {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub isCube: u8,
    pub sampleCount: Refresh_SampleCount,
    pub levelCount: u32,
    pub format: Refresh_TextureFormat,
    pub usageFlags: Refresh_TextureUsageFlags,
}
#[test]
fn bindgen_test_layout_Refresh_TextureCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_TextureCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(Refresh_TextureCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_TextureCreateInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_TextureCreateInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).height as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).isCube as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(isCube)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).sampleCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(sampleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).levelCount as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(levelCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).format as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureCreateInfo>())).usageFlags as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureCreateInfo),
            "::",
            stringify!(usageFlags)
        )
    );
}
impl Default for Refresh_TextureCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ShaderStageState {
    pub shaderModule: *mut Refresh_ShaderModule,
    pub entryPointName: *const ::std::os::raw::c_char,
    pub uniformBufferSize: u64,
}
#[test]
fn bindgen_test_layout_Refresh_ShaderStageState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ShaderStageState>(),
        24usize,
        concat!("Size of: ", stringify!(Refresh_ShaderStageState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ShaderStageState>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_ShaderStageState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ShaderStageState>())).shaderModule as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ShaderStageState),
            "::",
            stringify!(shaderModule)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ShaderStageState>())).entryPointName as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ShaderStageState),
            "::",
            stringify!(entryPointName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ShaderStageState>())).uniformBufferSize as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ShaderStageState),
            "::",
            stringify!(uniformBufferSize)
        )
    );
}
impl Default for Refresh_ShaderStageState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ViewportState {
    pub viewports: *const Refresh_Viewport,
    pub viewportCount: u32,
    pub scissors: *const Refresh_Rect,
    pub scissorCount: u32,
}
#[test]
fn bindgen_test_layout_Refresh_ViewportState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ViewportState>(),
        32usize,
        concat!("Size of: ", stringify!(Refresh_ViewportState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ViewportState>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_ViewportState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_ViewportState>())).viewports as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ViewportState),
            "::",
            stringify!(viewports)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ViewportState>())).viewportCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ViewportState),
            "::",
            stringify!(viewportCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_ViewportState>())).scissors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ViewportState),
            "::",
            stringify!(scissors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ViewportState>())).scissorCount as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ViewportState),
            "::",
            stringify!(scissorCount)
        )
    );
}
impl Default for Refresh_ViewportState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_RasterizerState {
    pub depthClampEnable: u8,
    pub fillMode: Refresh_FillMode,
    pub cullMode: Refresh_CullMode,
    pub frontFace: Refresh_FrontFace,
    pub depthBiasEnable: u8,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
}
#[test]
fn bindgen_test_layout_Refresh_RasterizerState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_RasterizerState>(),
        36usize,
        concat!("Size of: ", stringify!(Refresh_RasterizerState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_RasterizerState>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_RasterizerState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).depthClampEnable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(depthClampEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).fillMode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(fillMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).cullMode as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(cullMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).frontFace as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(frontFace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).depthBiasEnable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(depthBiasEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).depthBiasConstantFactor as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(depthBiasConstantFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).depthBiasClamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(depthBiasClamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).depthBiasSlopeFactor as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(depthBiasSlopeFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_RasterizerState>())).lineWidth as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_RasterizerState),
            "::",
            stringify!(lineWidth)
        )
    );
}
impl Default for Refresh_RasterizerState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_MultisampleState {
    pub multisampleCount: Refresh_SampleCount,
    pub sampleMask: u32,
}
#[test]
fn bindgen_test_layout_Refresh_MultisampleState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_MultisampleState>(),
        8usize,
        concat!("Size of: ", stringify!(Refresh_MultisampleState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_MultisampleState>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_MultisampleState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_MultisampleState>())).multisampleCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_MultisampleState),
            "::",
            stringify!(multisampleCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_MultisampleState>())).sampleMask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_MultisampleState),
            "::",
            stringify!(sampleMask)
        )
    );
}
impl Default for Refresh_MultisampleState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_DepthStencilState {
    pub depthTestEnable: u8,
    pub depthWriteEnable: u8,
    pub compareOp: Refresh_CompareOp,
    pub depthBoundsTestEnable: u8,
    pub stencilTestEnable: u8,
    pub frontStencilState: Refresh_StencilOpState,
    pub backStencilState: Refresh_StencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}
#[test]
fn bindgen_test_layout_Refresh_DepthStencilState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_DepthStencilState>(),
        76usize,
        concat!("Size of: ", stringify!(Refresh_DepthStencilState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_DepthStencilState>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_DepthStencilState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).depthTestEnable as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(depthTestEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).depthWriteEnable as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(depthWriteEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).compareOp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(compareOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).depthBoundsTestEnable as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(depthBoundsTestEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).stencilTestEnable as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(stencilTestEnable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).frontStencilState as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(frontStencilState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).backStencilState as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(backStencilState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).minDepthBounds as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(minDepthBounds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_DepthStencilState>())).maxDepthBounds as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_DepthStencilState),
            "::",
            stringify!(maxDepthBounds)
        )
    );
}
impl Default for Refresh_DepthStencilState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ColorBlendState {
    pub logicOpEnable: u8,
    pub logicOp: Refresh_LogicOp,
    pub blendStates: *const Refresh_ColorTargetBlendState,
    pub blendStateCount: u32,
    pub blendConstants: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_Refresh_ColorBlendState() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ColorBlendState>(),
        40usize,
        concat!("Size of: ", stringify!(Refresh_ColorBlendState))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ColorBlendState>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_ColorBlendState))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorBlendState>())).logicOpEnable as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorBlendState),
            "::",
            stringify!(logicOpEnable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_ColorBlendState>())).logicOp as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorBlendState),
            "::",
            stringify!(logicOp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorBlendState>())).blendStates as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorBlendState),
            "::",
            stringify!(blendStates)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorBlendState>())).blendStateCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorBlendState),
            "::",
            stringify!(blendStateCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ColorBlendState>())).blendConstants as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ColorBlendState),
            "::",
            stringify!(blendConstants)
        )
    );
}
impl Default for Refresh_ColorBlendState {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_ComputePipelineCreateInfo {
    pub computeShaderState: Refresh_ShaderStageState,
    pub pipelineLayoutCreateInfo: Refresh_ComputePipelineLayoutCreateInfo,
}
#[test]
fn bindgen_test_layout_Refresh_ComputePipelineCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_ComputePipelineCreateInfo>(),
        32usize,
        concat!("Size of: ", stringify!(Refresh_ComputePipelineCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_ComputePipelineCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_ComputePipelineCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ComputePipelineCreateInfo>())).computeShaderState
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ComputePipelineCreateInfo),
            "::",
            stringify!(computeShaderState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_ComputePipelineCreateInfo>())).pipelineLayoutCreateInfo
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_ComputePipelineCreateInfo),
            "::",
            stringify!(pipelineLayoutCreateInfo)
        )
    );
}
impl Default for Refresh_ComputePipelineCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_GraphicsPipelineCreateInfo {
    pub vertexShaderState: Refresh_ShaderStageState,
    pub fragmentShaderState: Refresh_ShaderStageState,
    pub vertexInputState: Refresh_VertexInputState,
    pub primitiveType: Refresh_PrimitiveType,
    pub viewportState: Refresh_ViewportState,
    pub rasterizerState: Refresh_RasterizerState,
    pub multisampleState: Refresh_MultisampleState,
    pub depthStencilState: Refresh_DepthStencilState,
    pub colorBlendState: Refresh_ColorBlendState,
    pub pipelineLayoutCreateInfo: Refresh_GraphicsPipelineLayoutCreateInfo,
    pub renderPass: *mut Refresh_RenderPass,
}
#[test]
fn bindgen_test_layout_Refresh_GraphicsPipelineCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_GraphicsPipelineCreateInfo>(),
        296usize,
        concat!("Size of: ", stringify!(Refresh_GraphicsPipelineCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_GraphicsPipelineCreateInfo>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_GraphicsPipelineCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).vertexShaderState
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(vertexShaderState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).fragmentShaderState
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(fragmentShaderState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).vertexInputState
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(vertexInputState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).primitiveType as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(primitiveType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).viewportState as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(viewportState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).rasterizerState
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(rasterizerState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).multisampleState
                as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(multisampleState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).depthStencilState
                as *const _ as usize
        },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(depthStencilState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).colorBlendState
                as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(colorBlendState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).pipelineLayoutCreateInfo
                as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(pipelineLayoutCreateInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_GraphicsPipelineCreateInfo>())).renderPass as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_GraphicsPipelineCreateInfo),
            "::",
            stringify!(renderPass)
        )
    );
}
impl Default for Refresh_GraphicsPipelineCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Refresh_FramebufferCreateInfo {
    pub renderPass: *mut Refresh_RenderPass,
    pub pColorTargets: *mut *mut Refresh_RenderTarget,
    pub colorTargetCount: u32,
    pub pDepthStencilTarget: *mut Refresh_RenderTarget,
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_Refresh_FramebufferCreateInfo() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_FramebufferCreateInfo>(),
        40usize,
        concat!("Size of: ", stringify!(Refresh_FramebufferCreateInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_FramebufferCreateInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Refresh_FramebufferCreateInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_FramebufferCreateInfo>())).renderPass as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_FramebufferCreateInfo),
            "::",
            stringify!(renderPass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_FramebufferCreateInfo>())).pColorTargets as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_FramebufferCreateInfo),
            "::",
            stringify!(pColorTargets)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_FramebufferCreateInfo>())).colorTargetCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_FramebufferCreateInfo),
            "::",
            stringify!(colorTargetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_FramebufferCreateInfo>())).pDepthStencilTarget
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_FramebufferCreateInfo),
            "::",
            stringify!(pDepthStencilTarget)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_FramebufferCreateInfo>())).width as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_FramebufferCreateInfo),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_FramebufferCreateInfo>())).height as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_FramebufferCreateInfo),
            "::",
            stringify!(height)
        )
    );
}
impl Default for Refresh_FramebufferCreateInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const Refresh_SysRendererType_REFRESH_RENDERER_TYPE_VULKAN: Refresh_SysRendererType = 0;
pub type Refresh_SysRendererType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Refresh_SysRenderer {
    pub rendererType: Refresh_SysRendererType,
    pub renderer: Refresh_SysRenderer__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Refresh_SysRenderer__bindgen_ty_1 {
    pub filler: [u8; 64usize],
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_Refresh_SysRenderer__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_SysRenderer__bindgen_ty_1>(),
        64usize,
        concat!("Size of: ", stringify!(Refresh_SysRenderer__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_SysRenderer__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_SysRenderer__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SysRenderer__bindgen_ty_1>())).filler as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SysRenderer__bindgen_ty_1),
            "::",
            stringify!(filler)
        )
    );
}
impl Default for Refresh_SysRenderer__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Refresh_SysRenderer() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_SysRenderer>(),
        68usize,
        concat!("Size of: ", stringify!(Refresh_SysRenderer))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_SysRenderer>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_SysRenderer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_SysRenderer>())).rendererType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SysRenderer),
            "::",
            stringify!(rendererType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_SysRenderer>())).renderer as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_SysRenderer),
            "::",
            stringify!(renderer)
        )
    );
}
impl Default for Refresh_SysRenderer {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Refresh_TextureHandles {
    pub rendererType: Refresh_SysRendererType,
    pub texture: Refresh_TextureHandles__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Refresh_TextureHandles__bindgen_ty_1 {
    pub filler: [u8; 64usize],
    _bindgen_union_align: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_Refresh_TextureHandles__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_TextureHandles__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(Refresh_TextureHandles__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_TextureHandles__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(Refresh_TextureHandles__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureHandles__bindgen_ty_1>())).filler as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureHandles__bindgen_ty_1),
            "::",
            stringify!(filler)
        )
    );
}
impl Default for Refresh_TextureHandles__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_Refresh_TextureHandles() {
    assert_eq!(
        ::std::mem::size_of::<Refresh_TextureHandles>(),
        68usize,
        concat!("Size of: ", stringify!(Refresh_TextureHandles))
    );
    assert_eq!(
        ::std::mem::align_of::<Refresh_TextureHandles>(),
        4usize,
        concat!("Alignment of ", stringify!(Refresh_TextureHandles))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<Refresh_TextureHandles>())).rendererType as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureHandles),
            "::",
            stringify!(rendererType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Refresh_TextureHandles>())).texture as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Refresh_TextureHandles),
            "::",
            stringify!(texture)
        )
    );
}
impl Default for Refresh_TextureHandles {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn Refresh_LinkedVersion() -> u32;
}
pub type Refresh_LogFunc =
    ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn Refresh_HookLogFunctions(
        info: Refresh_LogFunc,
        warn: Refresh_LogFunc,
        error: Refresh_LogFunc,
    );
}
extern "C" {
    pub fn Refresh_CreateDevice(
        presentationParameters: *mut Refresh_PresentationParameters,
        debugMode: u8,
    ) -> *mut Refresh_Device;
}
extern "C" {
    pub fn Refresh_CreateDeviceUsingExternal(
        sysRenderer: *mut Refresh_SysRenderer,
        debugMode: u8,
    ) -> *mut Refresh_Device;
}
extern "C" {
    pub fn Refresh_DestroyDevice(device: *mut Refresh_Device);
}
extern "C" {
    pub fn Refresh_Clear(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        clearRect: *mut Refresh_Rect,
        options: Refresh_ClearOptions,
        colors: *mut Refresh_Vec4,
        colorCount: u32,
        depthStencil: Refresh_DepthStencilValue,
    );
}
extern "C" {
    pub fn Refresh_DrawInstancedPrimitives(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        baseVertex: u32,
        startIndex: u32,
        primitiveCount: u32,
        instanceCount: u32,
        vertexParamOffset: u32,
        fragmentParamOffset: u32,
    );
}
extern "C" {
    pub fn Refresh_DrawIndexedPrimitives(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        baseVertex: u32,
        startIndex: u32,
        primitiveCount: u32,
        vertexParamOffset: u32,
        fragmentParamOffset: u32,
    );
}
extern "C" {
    pub fn Refresh_DrawPrimitives(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        vertexStart: u32,
        primitiveCount: u32,
        vertexParamOffset: u32,
        fragmentParamOffset: u32,
    );
}
extern "C" {
    pub fn Refresh_DispatchCompute(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        groupCountX: u32,
        groupCountY: u32,
        groupCountZ: u32,
        computeParamOffset: u32,
    );
}
extern "C" {
    pub fn Refresh_CreateRenderPass(
        device: *mut Refresh_Device,
        renderPassCreateInfo: *mut Refresh_RenderPassCreateInfo,
    ) -> *mut Refresh_RenderPass;
}
extern "C" {
    pub fn Refresh_CreateComputePipeline(
        device: *mut Refresh_Device,
        pipelineCreateInfo: *mut Refresh_ComputePipelineCreateInfo,
    ) -> *mut Refresh_ComputePipeline;
}
extern "C" {
    pub fn Refresh_CreateGraphicsPipeline(
        device: *mut Refresh_Device,
        pipelineCreateInfo: *mut Refresh_GraphicsPipelineCreateInfo,
    ) -> *mut Refresh_GraphicsPipeline;
}
extern "C" {
    pub fn Refresh_CreateSampler(
        device: *mut Refresh_Device,
        samplerStateCreateInfo: *mut Refresh_SamplerStateCreateInfo,
    ) -> *mut Refresh_Sampler;
}
extern "C" {
    pub fn Refresh_CreateFramebuffer(
        device: *mut Refresh_Device,
        framebufferCreateInfo: *mut Refresh_FramebufferCreateInfo,
    ) -> *mut Refresh_Framebuffer;
}
extern "C" {
    pub fn Refresh_CreateShaderModule(
        device: *mut Refresh_Device,
        shaderModuleCreateInfo: *mut Refresh_ShaderModuleCreateInfo,
    ) -> *mut Refresh_ShaderModule;
}
extern "C" {
    pub fn Refresh_CreateTexture(
        device: *mut Refresh_Device,
        textureCreateInfo: *mut Refresh_TextureCreateInfo,
    ) -> *mut Refresh_Texture;
}
extern "C" {
    pub fn Refresh_CreateRenderTarget(
        device: *mut Refresh_Device,
        textureSlice: *mut Refresh_TextureSlice,
        multisampleCount: Refresh_SampleCount,
    ) -> *mut Refresh_RenderTarget;
}
extern "C" {
    pub fn Refresh_CreateBuffer(
        device: *mut Refresh_Device,
        usageFlags: Refresh_BufferUsageFlags,
        sizeInBytes: u32,
    ) -> *mut Refresh_Buffer;
}
extern "C" {
    pub fn Refresh_SetTextureData(
        driverData: *mut Refresh_Device,
        textureSlice: *mut Refresh_TextureSlice,
        data: *mut ::std::os::raw::c_void,
        dataLengthInBytes: u32,
    );
}
extern "C" {
    pub fn Refresh_SetTextureDataYUV(
        driverData: *mut Refresh_Device,
        y: *mut Refresh_Texture,
        u: *mut Refresh_Texture,
        v: *mut Refresh_Texture,
        yWidth: u32,
        yHeight: u32,
        uvWidth: u32,
        uvHeight: u32,
        data: *mut ::std::os::raw::c_void,
        dataLength: u32,
    );
}
extern "C" {
    pub fn Refresh_CopyTextureToTexture(
        driverData: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        sourceTextureSlice: *mut Refresh_TextureSlice,
        destinationTextureSlice: *mut Refresh_TextureSlice,
        filter: Refresh_Filter,
    );
}
extern "C" {
    pub fn Refresh_CopyTextureToBuffer(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        textureSlice: *mut Refresh_TextureSlice,
        buffer: *mut Refresh_Buffer,
    );
}
extern "C" {
    pub fn Refresh_SetBufferData(
        device: *mut Refresh_Device,
        buffer: *mut Refresh_Buffer,
        offsetInBytes: u32,
        data: *mut ::std::os::raw::c_void,
        dataLength: u32,
    );
}
extern "C" {
    pub fn Refresh_PushVertexShaderUniforms(
        device: *mut Refresh_Device,
        pipeline: *mut Refresh_GraphicsPipeline,
        data: *mut ::std::os::raw::c_void,
        dataLengthInBytes: u32,
    ) -> u32;
}
extern "C" {
    pub fn Refresh_PushFragmentShaderUniforms(
        device: *mut Refresh_Device,
        pipeline: *mut Refresh_GraphicsPipeline,
        data: *mut ::std::os::raw::c_void,
        dataLengthInBytes: u32,
    ) -> u32;
}
extern "C" {
    pub fn Refresh_PushComputeShaderUniforms(
        device: *mut Refresh_Device,
        pipeline: *mut Refresh_ComputePipeline,
        data: *mut ::std::os::raw::c_void,
        dataLengthInBytes: u32,
    ) -> u32;
}
extern "C" {
    pub fn Refresh_GetBufferData(
        device: *mut Refresh_Device,
        buffer: *mut Refresh_Buffer,
        data: *mut ::std::os::raw::c_void,
        dataLengthInBytes: u32,
    );
}
extern "C" {
    pub fn Refresh_QueueDestroyTexture(device: *mut Refresh_Device, texture: *mut Refresh_Texture);
}
extern "C" {
    pub fn Refresh_QueueDestroySampler(device: *mut Refresh_Device, sampler: *mut Refresh_Sampler);
}
extern "C" {
    pub fn Refresh_QueueDestroyBuffer(device: *mut Refresh_Device, buffer: *mut Refresh_Buffer);
}
extern "C" {
    pub fn Refresh_QueueDestroyRenderTarget(
        device: *mut Refresh_Device,
        renderTarget: *mut Refresh_RenderTarget,
    );
}
extern "C" {
    pub fn Refresh_QueueDestroyFramebuffer(
        device: *mut Refresh_Device,
        frameBuffer: *mut Refresh_Framebuffer,
    );
}
extern "C" {
    pub fn Refresh_QueueDestroyShaderModule(
        device: *mut Refresh_Device,
        shaderModule: *mut Refresh_ShaderModule,
    );
}
extern "C" {
    pub fn Refresh_QueueDestroyRenderPass(
        device: *mut Refresh_Device,
        renderPass: *mut Refresh_RenderPass,
    );
}
extern "C" {
    pub fn Refresh_QueueDestroyComputePipeline(
        device: *mut Refresh_Device,
        computePipeline: *mut Refresh_ComputePipeline,
    );
}
extern "C" {
    pub fn Refresh_QueueDestroyGraphicsPipeline(
        device: *mut Refresh_Device,
        graphicsPipeline: *mut Refresh_GraphicsPipeline,
    );
}
extern "C" {
    pub fn Refresh_BeginRenderPass(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        renderPass: *mut Refresh_RenderPass,
        framebuffer: *mut Refresh_Framebuffer,
        renderArea: *mut Refresh_Rect,
        pColorClearValues: *mut Refresh_Vec4,
        colorClearCount: u32,
        depthStencilClearValue: *mut Refresh_DepthStencilValue,
    );
}
extern "C" {
    pub fn Refresh_EndRenderPass(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
    );
}
extern "C" {
    pub fn Refresh_BindGraphicsPipeline(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        graphicsPipeline: *mut Refresh_GraphicsPipeline,
    );
}
extern "C" {
    pub fn Refresh_BindVertexBuffers(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        firstBinding: u32,
        bindingCount: u32,
        pBuffers: *mut *mut Refresh_Buffer,
        pOffsets: *mut u64,
    );
}
extern "C" {
    pub fn Refresh_BindIndexBuffer(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        buffer: *mut Refresh_Buffer,
        offset: u64,
        indexElementSize: Refresh_IndexElementSize,
    );
}
extern "C" {
    pub fn Refresh_BindVertexSamplers(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        pTextures: *mut *mut Refresh_Texture,
        pSamplers: *mut *mut Refresh_Sampler,
    );
}
extern "C" {
    pub fn Refresh_BindFragmentSamplers(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        pTextures: *mut *mut Refresh_Texture,
        pSamplers: *mut *mut Refresh_Sampler,
    );
}
extern "C" {
    pub fn Refresh_BindComputePipeline(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        computePipeline: *mut Refresh_ComputePipeline,
    );
}
extern "C" {
    pub fn Refresh_BindComputeBuffers(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        pBuffers: *mut *mut Refresh_Buffer,
    );
}
extern "C" {
    pub fn Refresh_BindComputeTextures(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        pTextures: *mut *mut Refresh_Texture,
    );
}
extern "C" {
    pub fn Refresh_AcquireCommandBuffer(
        device: *mut Refresh_Device,
        fixed: u8,
    ) -> *mut Refresh_CommandBuffer;
}
extern "C" {
    pub fn Refresh_QueuePresent(
        device: *mut Refresh_Device,
        commandBuffer: *mut Refresh_CommandBuffer,
        textureSlice: *mut Refresh_TextureSlice,
        destinationRectangle: *mut Refresh_Rect,
        filter: Refresh_Filter,
    );
}
extern "C" {
    pub fn Refresh_Submit(
        device: *mut Refresh_Device,
        commandBufferCount: u32,
        pCommandBuffers: *mut *mut Refresh_CommandBuffer,
    );
}
extern "C" {
    pub fn Refresh_Wait(device: *mut Refresh_Device);
}
extern "C" {
    pub fn Refresh_GetTextureHandles(
        device: *mut Refresh_Device,
        texture: *mut Refresh_Texture,
        handles: *mut Refresh_TextureHandles,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
